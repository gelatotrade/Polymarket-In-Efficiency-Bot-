"""
Data models for trading strategy.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, List
from enum import Enum


class SignalType(Enum):
    """Type of trading signal."""
    BUY_YES = "buy_yes"      # Price going up, buy Yes
    BUY_NO = "buy_no"        # Price going down, buy No
    CLOSE_POSITION = "close"
    NO_ACTION = "no_action"


class SignalStrength(Enum):
    """Strength of the signal."""
    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"
    VERY_STRONG = "very_strong"


@dataclass
class Signal:
    """
    Trading signal generated by the strategy.
    """
    symbol: str
    signal_type: SignalType
    strength: SignalStrength
    oracle_price: float
    market_price: float
    price_threshold: float
    lag_seconds: float
    price_diff_pct: float
    confidence: float
    timestamp: datetime = field(default_factory=datetime.utcnow)
    reason: str = ""
    market_id: Optional[str] = None
    token_id: Optional[str] = None
    recommended_size: float = 0.0
    expected_profit_pct: float = 0.0

    @property
    def is_actionable(self) -> bool:
        """Check if signal should be acted upon."""
        return (
            self.signal_type != SignalType.NO_ACTION and
            self.strength in [SignalStrength.MODERATE, SignalStrength.STRONG, SignalStrength.VERY_STRONG] and
            self.confidence >= 0.6
        )

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "strength": self.strength.value,
            "oracle_price": self.oracle_price,
            "market_price": self.market_price,
            "price_threshold": self.price_threshold,
            "lag_seconds": self.lag_seconds,
            "price_diff_pct": self.price_diff_pct,
            "confidence": self.confidence,
            "timestamp": self.timestamp.isoformat(),
            "reason": self.reason,
            "market_id": self.market_id,
            "token_id": self.token_id,
            "recommended_size": self.recommended_size,
            "expected_profit_pct": self.expected_profit_pct,
            "is_actionable": self.is_actionable
        }


@dataclass
class TradeAction:
    """
    Trade action to be executed.
    """
    action_id: str
    signal: Signal
    token_id: str
    side: str  # "BUY" or "SELL"
    price: float
    size: float
    order_type: str = "GTC"
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    max_slippage: float = 0.01
    created_at: datetime = field(default_factory=datetime.utcnow)
    executed: bool = False
    executed_at: Optional[datetime] = None
    execution_price: Optional[float] = None
    order_id: Optional[str] = None

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "action_id": self.action_id,
            "symbol": self.signal.symbol,
            "token_id": self.token_id,
            "side": self.side,
            "price": self.price,
            "size": self.size,
            "order_type": self.order_type,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "executed": self.executed,
            "execution_price": self.execution_price,
            "created_at": self.created_at.isoformat()
        }


@dataclass
class StrategyState:
    """
    Current state of the trading strategy.
    """
    is_active: bool = False
    is_trading_enabled: bool = False
    total_signals_generated: int = 0
    actionable_signals: int = 0
    trades_executed: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: float = 0.0
    current_positions: int = 0
    daily_pnl: float = 0.0
    daily_trades: int = 0
    last_signal_time: Optional[datetime] = None
    last_trade_time: Optional[datetime] = None
    started_at: Optional[datetime] = None

    @property
    def win_rate(self) -> float:
        """Calculate win rate."""
        total = self.winning_trades + self.losing_trades
        return (self.winning_trades / total * 100) if total > 0 else 0.0

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "is_active": self.is_active,
            "is_trading_enabled": self.is_trading_enabled,
            "total_signals": self.total_signals_generated,
            "actionable_signals": self.actionable_signals,
            "trades_executed": self.trades_executed,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "win_rate": self.win_rate,
            "total_pnl": self.total_pnl,
            "current_positions": self.current_positions,
            "daily_pnl": self.daily_pnl,
            "daily_trades": self.daily_trades,
            "last_signal_time": self.last_signal_time.isoformat() if self.last_signal_time else None,
            "last_trade_time": self.last_trade_time.isoformat() if self.last_trade_time else None,
            "started_at": self.started_at.isoformat() if self.started_at else None
        }


@dataclass
class LagOpportunity:
    """
    Detected lag-based trading opportunity.
    """
    symbol: str
    oracle_price: float
    oracle_timestamp: datetime
    market_implied_price: float
    market_timestamp: datetime
    market: "Market"  # Forward reference
    lag_seconds: float
    price_diff_pct: float
    direction: str  # "UP" or "DOWN"
    opportunity_window_seconds: float
    detected_at: datetime = field(default_factory=datetime.utcnow)

    @property
    def is_valid(self) -> bool:
        """Check if opportunity is still valid."""
        age = (datetime.utcnow() - self.detected_at).total_seconds()
        return age < self.opportunity_window_seconds

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "symbol": self.symbol,
            "oracle_price": self.oracle_price,
            "market_implied_price": self.market_implied_price,
            "lag_seconds": self.lag_seconds,
            "price_diff_pct": self.price_diff_pct,
            "direction": self.direction,
            "opportunity_window_seconds": self.opportunity_window_seconds,
            "is_valid": self.is_valid,
            "detected_at": self.detected_at.isoformat()
        }
